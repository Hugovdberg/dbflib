function [success, num_errors, errors] = build_info()
%BUILD_INFO Tests building info for DBF header
    tic

    tests = {...
        @no_field_no_record, ...
        @no_field_single_record, ...
        @single_field_no_record, ...
        @single_integer_field_single_record, ...
        @single_integer_field_multiple_records, ...
        @single_double_field_single_record, ...
        @single_double_field_multiple_records, ...
        @single_char_field_single_record, ...
        @single_char_field_single_record2, ...
        @single_char_field_too_long_record, ...
        @single_char_field_multiple_records, ...
        @single_char_field_multiple_unequal_records, ...
        @single_logical_field_single_record, ...
        @single_logical_field_multiple_records, ...
        @tristate_unspecified_logical_field_multiple_records, ...
        @int_and_char_field_single_record, ...
        @int_and_char_field_multiple_records, ...
        @info_struct_single_field_no_record, ...
        @info_struct_single_integer_field_single_record, ...
        @info_struct_single_integer_to_double_field_single_record, ...
        @total_struct_single_integer_to_double_field_single_record};

    tsuccess = true;
    tnum_tests = length(tests);
    tnum_errors = 0;
    terrors = cell(size(tests));

    if rem(now, 1) < 3e-4 || rem(now, 1) > 1-3e-4
        warning('Close to midniiiight, tests might fail on filemoddate')
    end

    for k = 1:tnum_tests
        testfun = tests{k};
        try
            testfun();
        catch err
            terrors{k} = err;
            tsuccess = false;
            tnum_errors = tnum_errors+1;
        end
    end
    
    time = toc;
    fprintf(['Run %d tests in %.3f seconds\n'...
             '%d tests succeeded, %d tests failed\n'], ...
            tnum_tests, time, tnum_tests-tnum_errors, tnum_errors);
    terrors = terrors(~cellfun(@isempty, terrors));
    if nargout > 0
        success = tsuccess;
        num_errors = tnum_errors;
        errors = terrors;
    end
end

function no_field_no_record()
    data = {};
    info = {};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 0, ...
                      'NumFields', 0, ...
                      'HeaderLength', 33, ...
                      'RecordLength', 0, ...
                      'FieldInfo', repmat(struct('Name', '', ...
                                                 'Length', 0, ...
                                                 'Decimals', 0, ...
                                                 'RawType', ''), 0, 0));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_field_no_record()
    data = {};
    info = {'id'};

    try
        [~] = dbflib.mixin.build_info(data, info);
    catch err
    end
    
    assert(strcmp(err.identifier, 'DBFLIB:InvalidNumFields'))
end

function no_field_single_record()
    data = {1};
    info = {};

    try
        [~] = dbflib.mixin.build_info(data, info);
    catch err
    end
    
    assert(strcmp(err.identifier, 'DBFLIB:InvalidNumFields'))
end

function single_integer_field_single_record()
    data = {1};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 2, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 1, ...
                                          'Decimals', 0, ...
                                          'RawType', 'N'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_integer_field_multiple_records()
    % Check single integer field, multiple records
    data = {1; 2};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 2, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 2, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 1, ...
                                          'Decimals', 0, ...
                                          'RawType', 'N'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_double_field_single_record()
    data = {1.1};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 21, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 20, ...
                                          'Decimals', 18, ...
                                          'RawType', 'F'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_double_field_multiple_records()
    data = {1.1; 1.1};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 2, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 21, ... (20 for field, 1 for deletionflag)
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 20, ...
                                          'Decimals', 18, ...
                                          'RawType', 'F'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_char_field_single_record()
    data = {'A'};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 2, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 1, ...
                                          'Decimals', 0, ...
                                          'RawType', 'C'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_char_field_single_record2()
    data = {'Abcd'};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 5, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 4, ...
                                          'Decimals', 0, ...
                                          'RawType', 'C'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_char_field_too_long_record()
    data = {repmat('A', 1, 256)};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 255, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 254, ...
                                          'Decimals', 0, ...
                                          'RawType', 'C'));

    warning('off', 'DBFLIB:BUILD_INFO:PrecisionLoss')
    info = dbflib.mixin.build_info(data, info);
    [wrnmsg, wrnid] = lastwarn();
    warning('on', 'DBFLIB:BUILD_INFO:PrecisionLoss')

    assert(strcmp(wrnid, 'DBFLIB:BUILD_INFO:PrecisionLoss'), ...
           'Expected warning truncated string, instead got warning:\n', ...
           wrnmsg);
    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_char_field_multiple_records()
    data = {'A';'B'};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 2, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 2, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 1, ...
                                          'Decimals', 0, ...
                                          'RawType', 'C'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_char_field_multiple_unequal_records()
    data = {'A';'Bcd'};
    info = {'id'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 2, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 4, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 3, ...
                                          'Decimals', 0, ...
                                          'RawType', 'C'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_logical_field_single_record()
    data = {true};
    info = {'test'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 2, ...
                      'FieldInfo', struct('Name', 'test', ...
                                          'Length', 1, ...
                                          'Decimals', 0, ...
                                          'RawType', 'L'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function single_logical_field_multiple_records()
    data = {true; false};
    info = {'test'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 2, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 2, ...
                      'FieldInfo', struct('Name', 'test', ...
                                          'Length', 1, ...
                                          'Decimals', 0, ...
                                          'RawType', 'L'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function tristate_unspecified_logical_field_multiple_records()
    data = {1; 0; NaN};
    info = {'test'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 3, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 21, ...
                      'FieldInfo', struct('Name', 'test', ...
                                          'Length', 20, ...
                                          'Decimals', 18, ...
                                          'RawType', 'F'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function int_and_char_field_single_record()
    data = {1, 'Bcd'};
    info = {'id', 'naam'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 2, ...
                      'HeaderLength', 97, ...
                      'RecordLength', 5, ...
                      'FieldInfo', struct('Name', {'id', 'naam'}, ...
                                          'Length', {1, 3}, ...
                                          'Decimals', {0, 0}, ...
                                          'RawType', {'N', 'C'}));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function int_and_char_field_multiple_records()
    % Check single double field, multiple records
    data = {1, 'Bcd'; 34, 'asdfghjkl'};
    info = {'id', 'naam'};
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 2, ...
                      'NumFields', 2, ...
                      'HeaderLength', 97, ...
                      'RecordLength', 12, ...
                      'FieldInfo', struct('Name', {'id', 'naam'}, ...
                                          'Length', {2, 9}, ...
                                          'Decimals', {0, 0}, ...
                                          'RawType', {'N', 'C'}));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function info_struct_single_field_no_record()
    data = {};
    info = struct('Name', 'id', ...
                  'Length', 1, ...
                  'Decimals', 0, ...
                  'RawType', 'C');
    try
        [~] = dbflib.mixin.build_info(data, info);
    catch err
    end
    assert(strcmp(err.identifier, 'DBFLIB:InvalidNumFields'))
end

function info_struct_single_integer_field_single_record()
    data = {1};
    info = struct('Name', 'id', ...
                  'Length', 1, ...
                  'Decimals', 0, ...
                  'RawType', 'N');
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 2, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 1, ...
                                          'Decimals', 0, ...
                                          'RawType', 'N'));

    info = dbflib.mixin.build_info(data, info);

    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function info_struct_single_integer_to_double_field_single_record()
    % Setup
    data = {1};
    info = struct('Name', 'id', ...
                  'Length', 20, ...
                  'Decimals', 18, ...
                  'RawType', 'F');
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 21, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 20, ...
                                          'Decimals', 18, ...
                                          'RawType', 'F'));

    % Act
    info = dbflib.mixin.build_info(data, info);

    % Assert
    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end

function total_struct_single_integer_to_double_field_single_record()
    % Setup
    data = {1};
    info = struct('DBFVersion', 0, ...
                  'FileModDate', 0, ...
                  'NumRecords', 0, ...
                  'NumFields', 0, ...
                  'HeaderLength', 0, ...
                  'RecordLength', 0, ...
                  'FieldInfo', struct('Name', 'id', ...
                                      'Length', 0, ...
                                      'Decimals', 0, ...
                                      'RawType', 'F'));
    testInfo = struct('DBFVersion', 3, ...
                      'FileModDate', floor(now), ...
                      'NumRecords', 1, ...
                      'NumFields', 1, ...
                      'HeaderLength', 65, ...
                      'RecordLength', 21, ...
                      'FieldInfo', struct('Name', 'id', ...
                                          'Length', 20, ...
                                          'Decimals', 18, ...
                                          'RawType', 'F'));

    % Act
    info = dbflib.mixin.build_info(data, info);

    % Assert
    assert(isfield(info, 'FileModDate'))
    info.FileModDate = floor(info.FileModDate);
    assert(dbflibtest.mixin.compare_structs(info, testInfo))
end
